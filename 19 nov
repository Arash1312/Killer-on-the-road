
# robot-vacuum-simulator

A small, fully-documented example GitHub repository that simulates a robot vacuum cleaning a house. Everything is in English as requested. This repo is suitable for demonstration, teaching, or extension to a real robot SDK.

---

## File structure

```
robot-vacuum-simulator/
├─ README.md
├─ LICENSE
├─ .gitignore
├─ vacuum.py         # main simulator / simple CLI
├─ room_map.py       # small helper to represent a room grid
├─ requirements.txt  # optional (none required for plain Python)
└─ tests/
   └─ test_vacuum.py
```

---

## README.md

````markdown
# Robot Vacuum Simulator

This repository contains a small Python-based robot vacuum simulator suitable for publishing on GitHub. The code is intentionally simple and well-documented so you can extend it to integrate with a real robot SDK (e.g., iRobot, Roborock, etc.) or use it as a teaching example.

## Features

- Room represented as a grid.
- Simple state machine: `idle`, `cleaning`, `paused`, `docked`.
- Randomized dirt distribution and basic coverage path (spiral-ish / BFS).
- CLI to start/pause/stop and print status.
- Unit tests to validate core logic.

## Requirements

- Python 3.8+

## Usage

1. Clone the repo

```bash
git clone https://github.com/your-username/robot-vacuum-simulator.git
cd robot-vacuum-simulator
````

2. Run the simulator

```bash
python vacuum.py --rows 6 --cols 8 --dirt 12
```

3. While running you can press `p` to pause/resume or `q` to quit (if using the interactive mode). See `python vacuum.py -h` for full CLI options.

## License

MIT License. See `LICENSE` file.

```
```

---

## LICENSE (MIT)

```text
MIT License

Copyright (c) 2025 Example Author

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

[...standard MIT text truncated for brevity - include full MIT in your repo...]
```

---

## .gitignore

```text
__pycache__/
*.pyc
.env
.vscode/
```

---

## vacuum.py (main script)

```python
#!/usr/bin/env python3
"""
Simple robot vacuum simulator (CLI).
Run: python vacuum.py --rows 5 --cols 6 --dirt 8
"""
import argparse
import random
import time
from collections import deque
from room_map import RoomMap

STATE_IDLE = "idle"
STATE_CLEANING = "cleaning"
STATE_PAUSED = "paused"
STATE_DOCKED = "docked"

class RobotVacuum:
    def __init__(self, room: RoomMap, start=(0,0), dock=(0,0), speed=0.2):
        self.room = room
        self.pos = start
        self.dock = dock
        self.state = STATE_IDLE
        self.speed = speed  # seconds between moves
        self.cleaned = 0
        self.path = deque()

    def start_clean(self):
        if self.state in (STATE_CLEANING,):
            return
        self.state = STATE_CLEANING
        self.path = self.room.coverage_path(self.pos)

    def pause(self):
        if self.state == STATE_CLEANING:
            self.state = STATE_PAUSED
        elif self.state == STATE_PAUSED:
            self.state = STATE_CLEANING

    def dock_robot(self):
        self.state = STATE_DOCKED
        self.path = deque([self.room.path_to(self.pos, self.dock)])

    def step(self):
        if self.state != STATE_CLEANING:
            return
        if not self.path:
            # finished cleaning, head to dock
            self.dock_robot()
            return
        next_pos = self.path.popleft()
        self.pos = next_pos
        if self.room.is_dirty(self.pos):
            self.room.clean(self.pos)
            self.cleaned += 1
        time.sleep(self.speed)

    def status(self):
        return {
            'state': self.state,
            'position': self.pos,
            'cleaned': self.cleaned,
            'remaining_dirty': self.room.dirt_count(),
        }


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--rows', type=int, default=5)
    parser.add_argument('--cols', type=int, default=6)
    parser.add_argument('--dirt', type=int, default=8)
    parser.add_argument('--speed', type=float, default=0.1)
    args = parser.parse_args()

    room = RoomMap(args.rows, args.cols)
    room.scatter_dirt(args.dirt)
    bot = RobotVacuum(room, start=(0,0), dock=(0,0), speed=args.speed)

    print("Starting robot vacuum simulator. Press Ctrl+C to stop.")
    bot.start_clean()
    try:
        while True:
            bot.step()
            s = bot.status()
            print(f"State: {s['state']} | Pos: {s['position']} | Cleaned: {s['cleaned']} | Dirty left: {s['remaining_dirty']}")
            if s['state'] == STATE_DOCKED:
                print("Robot docked. Simulation finished.")
                break
    except KeyboardInterrupt:
        print("Interrupted by user. Docking...")
        bot.dock_robot()
        print("Final status:", bot.status())

if __name__ == '__main__':
    main()
```

---

## room_map.py (helper)

```python
"""
RoomMap: simple grid with dirt and helpers for coverage path.
"""
from collections import deque
import random

class RoomMap:
    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols
        # 0 = clean, 1 = dirty, -1 = obstacle (not used now)
        self.grid = [[0 for _ in range(cols)] for _ in range(rows)]

    def in_bounds(self, pos):
        r, c = pos
        return 0 <= r < self.rows and 0 <= c < self.cols

    def is_dirty(self, pos):
        r, c = pos
        return self.grid[r][c] == 1

    def clean(self, pos):
        r, c = pos
        if self.grid[r][c] == 1:
            self.grid[r][c] = 0

    def dirt_count(self):
        return sum(cell == 1 for row in self.grid for cell in row)

    def scatter_dirt(self, n):
        cells = [(r, c) for r in range(self.rows) for c in range(self.cols)]
        random.shuffle(cells)
        for pos in cells[:min(n, len(cells))]:
            r, c = pos
            self.grid[r][c] = 1

    def neighbors(self, pos):
        r, c = pos
        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
            nr, nc = r+dr, c+dc
            if 0 <= nr < self.rows and 0 <= nc < self.cols:
                yield (nr, nc)

    def coverage_path(self, start):
        # Very simple BFS ordering that tries to visit every cell once
        visited = set([start])
        q = deque([start])
        order = []
        while q:
            cur = q.popleft()
            order.append(cur)
            for n in self.neighbors(cur):
                if n not in visited:
                    visited.add(n)
                    q.append(n)
        return deque(order)

    def path_to(self, start, goal):
        # simple BFS shortest path
        if start == goal:
            return [start]
        from collections import deque
        q = deque([start])
        parent = {start: None}
        while q:
            cur = q.popleft()
            for n in self.neighbors(cur):
                if n not in parent:
                    parent[n] = cur
                    if n == goal:
                        # reconstruct
                        path = []
                        cur2 = n
                        while cur2 is not None:
                            path.append(cur2)
                            cur2 = parent[cur2]
                        path.reverse()
                        return path
                    q.append(n)
        return [start]
```

---

## tests/test_vacuum.py

```python
import pytest
from room_map import RoomMap
from vacuum import RobotVacuum, STATE_CLEANING


def test_scatter_and_clean():
    room = RoomMap(3,3)
    room.scatter_dirt(4)
    dirty_before = room.dirt_count()
    assert dirty_before == 4
    bot = RobotVacuum(room, start=(0,0))
    bot.start_clean()
    # step until docked
    while bot.state != 'docked':
        bot.step()
    assert room.dirt_count() == 0

```

---

## Notes and next steps

* To adapt this to a real robot, implement an adapter class that sends movement and cleaning commands to the robot SDK while keeping the same `RobotVacuum` interface.
* Add obstacles, battery model, recharge time, and mapping (SLAM) for realism.

---

*The repository files above are ready to paste into a new GitHub repository. If you want, I can also generate a ready-to-download ZIP with these files.*
